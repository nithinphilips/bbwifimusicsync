using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Threading;

namespace LibQdownloader.Threading
{
    /*
     * Guide to Implementing a WorkManager.
     * See <https://trac.nithinphilips.com/QDownloader/wiki/Multithreaded_operations> for full documentation.
     * 
     * At the minimum, you must implement the DoWork() method, like so:
     * 
     * ...
     * protected override bool DoWork(Script job)
     * {     
     *      Worker w = new Worker(job)
     *      bool result = false;
     *      
     *      // TODO: Subscribe to any events generated by the Worker
     *      
     *      // Register with base, so users can pause or cancel jobs.
     *      base.AddActiveWorker(engine);
     *      
     *      // store the result (success|fail) of the job
     *      result = w.Execute();
     *      
     *      // Unregister 
     *      base.RemoveActiveWorker(engine);
     *      
     *      return result;
     * }
     * ...
     * 
     *  If your Workers generate events such as detailed progress of the work, 
     *  you can catch the individual events are refire them.
     *  
     * ...
     * public event EventHandler<SampleEventArgs> SampleEvent;
     * 
     * void w_Sample(object sender, SampleEventArgs e)
     * {
     *      // by calling base.Post() we can ensure that the event is executed in the thread that
     *      // created our WorkManager, such as the UI thread. This saves the user from having to marshall
     *      // every event. If your event for some reason cannot be posted (such as you need to collect data 
     *      // from the user) ensure that it is obvious to the user of your WorkManager.
     *      base.Post<SampleEventArgs>(SampleEvent, e);
     * }
     * 
     * ...
     */



    /// <summary>
    /// An abstract multi-threaded work manager.
    /// A Job is any class that can be passed along to a Worker and related information regarding how to perform a task.
    /// <para>
    /// 
    /// </para>
    /// <para>
    /// Clients can inherit this class to manage work queues and perform work asynchronously.
    /// Implementing clients must realize the method DoWork() which will be called by one of the worker threads.
    /// </para>
    /// </summary>
    /// <typeparam name="TJob">The job this work manager manages</typeparam>
    /// <typeparam name="TWorker">The woker that does work of type TJob</typeparam>
    public abstract class WorkManager<TJob, TWorker> : IDisposable, ICancelable
        where TJob : class
        where TWorker : IDisposable, IPauseable
    {

        // see http://www.albahari.com/threading/part4.aspx#_UsingWaitPulse for information on 
        //     the pulsing model used in this implementation.

        
        log4net.ILog Log;
        string threadNamePrefix = string.Empty;

        AsyncOperation operation;

        List<TWorker> activeWorkers = new List<TWorker>();  // so we can pause them
        List<TJob> activeJobs = new List<TJob>();
        Queue<TJob> jobs = new Queue<TJob>();
        List<Thread> threads;

        bool isDisposed = false;
        volatile bool pause = false;

        // Access to all lists are synced on this object.
        readonly object syncLock = new object();
        readonly EventWaitHandle pauseHandle = new ManualResetEvent(true);

        #region Events

        /// <summary>
        /// Signals that a job is about to start. i.e. a Worker has been asked to do the job.
        /// </summary>
        public event EventHandler<JobEventArgs<TJob>> JobStarting;

        /// <summary>
        /// Signals that a job is complete.
        /// </summary>
        public event EventHandler<JobEventArgs<TJob>> JobCompleted;

        /// <summary>
        /// Signals that a job has failed.
        /// </summary>
        public event EventHandler<JobEventArgs<TJob>> JobFailed;

        /// <summary>
        /// Signals that all queued jobs are complete. May be signaled again if more jobs are added later.
        /// This signal implies that all workers are now idle.
        /// </summary>
        public event EventHandler WorkCompleted;

        /// <summary>
        /// Signals that the Pause() method has been called and all workers were asked to pause.
        /// </summary>
        public event EventHandler WorkPaused;

        /// <summary>
        /// Signals that the Resume() method has been called and all workers were asked to resume.
        /// </summary>
        public event EventHandler WorkResumed;

        /// <summary>
        /// Signals that all the resources held by this instance has been released.
        /// Calling any methods on the instance after this event will cause an ObjectDisposedException to be thrown.
        /// </summary>
        public event EventHandler Disposed;

        /// <summary>
        /// Invokes a generic EventHandler in a thread-safe manner. 
        /// All events are fired in the thread that created the instance of the implementation.
        /// </summary>
        /// <typeparam name="U">The EventArgs handled by the EventHandler.</typeparam>
        /// <param name="eventHandler">The EventHandler to invoke.</param>
        /// <param name="e">EventArgs to pass to the EventHandler.</param>
        protected void Post<U>(EventHandler<U> eventHandler, U e) where U : EventArgs
        {
            operation.Post(delegate(object state)
            {
                if (eventHandler != null)
                {
                    eventHandler(this, e);
                }
            }, null);
        }

        /// <summary>
        /// Invokes an EventHandler in a thread-safe manner. 
        /// All events are fired in the thread that created the instance of the implementation.
        /// </summary>
        /// <param name="eventHandler">The EventHandler to invoke.</param>
        /// <param name="e">EventArgs to pass to the EventHandler.</param>
        protected void Post(EventHandler eventHandler, EventArgs e)
        {
            operation.Post(delegate(object state)
            {
                if (eventHandler != null)
                {
                    eventHandler(this, e);
                }
            }, null);
        }

        protected void OnJobStarting(TJob job)
        {
            Post<JobEventArgs<TJob>>(JobStarting, new JobEventArgs<TJob>(job));
        }

        protected void OnJobCompleted(TJob job)
        {
            Post<JobEventArgs<TJob>>(JobCompleted, new JobEventArgs<TJob>(job));
        }

        protected void OnJobFailed(TJob job)
        {
            Post<JobEventArgs<TJob>>(JobFailed, new JobEventArgs<TJob>(job));
        }

        protected void OnWorkCompleted()
        {
            Post(WorkCompleted, EventArgs.Empty);
        }

        protected void OnWorkPaused()
        {
            Post(WorkPaused, EventArgs.Empty);
        }

        protected void OnWorkResumed()
        {
            Post(WorkResumed, EventArgs.Empty);
        }

        protected void OnDisposed()
        {
            Post(Disposed, EventArgs.Empty);
        }

        #endregion

        /// <summary>
        /// True, if work is paused. Otherwise false.
        /// </summary>
        public bool Paused
        {
            get { return pause; }
        }

        /// <summary>
        /// If true, the object has been disposed and no methods may be called. Otherwise false.
        /// </summary>
        public bool IsDisposed
        {
            get { return isDisposed; }
        }

        /// <summary>
        /// Gets the number of items in the queue, not including those that are being downloaded (Use ActiveDownloadCount for that)
        /// </summary>
        public int RemainingCount
        {
            get
            {
                lock (syncLock)
                {
                    return jobs.Count;
                }
            }
        }

        /// <summary>
        /// Gets the number of jobs that are currently running or paused.
        /// </summary>
        public int RunningCount
        {
            get
            {
                lock (syncLock)
                {
                    return activeJobs.Count;
                }
            }
        }

        /// <summary>
        /// Gets all the jobs that are currently running or paused.
        /// This collection will change as the jobs are completed.
        /// </summary>
        public System.Collections.ObjectModel.ReadOnlyCollection<TJob> ActiveJobs
        {
            get
            {
                lock (syncLock)
                {
                    return activeJobs.AsReadOnly();
                }
            }
        }

        /// <summary>
        /// Gets all the jobs that are currently running or paused.
        /// </summary>
        public System.Collections.ObjectModel.ReadOnlyCollection<TWorker> ActiveWorkers
        {
            get
            {
                lock (syncLock)
                {
                    return activeWorkers.AsReadOnly();
                }
            }
        }

        /// <summary>
        /// Creates a new instace of WorkManager with a specific number of worker threads.
        /// The events that are raised by this instance of WorkManager will also have affinity to the thread that created it.
        /// Therefore, to avoid having to marshall events to UI thread, create the instance of WorkManager from the UI thread.
        /// However, beware that any event that passes a CancelEventArgs object will not be automatically marshalled. 
        /// Do not update UI elements from such events without marshalling first.
        /// </summary>
        /// <param name="threadCount">The number of worker threads to create.</param>
        protected WorkManager(uint threadCount, log4net.ILog log, string threadNamePrefix)
        {
            this.threads = new List<Thread>((int)threadCount);

            this.threadNamePrefix = threadNamePrefix;
            this.Log = log;
            operation = AsyncOperationManager.CreateOperation(null); // attach to creating thread
            Log.Debug("Initializing Queue");
            AddThreads(threadCount);
        }


        void AddThreads(uint threadCount)
        {
            // create and start workers
            for (int i = 0; i < threadCount; i++)
            {
                AddThread();
            }
        }

        /// <summary>
        /// Add an additional download thread.
        /// </summary>
        public void AddThread()
        {
            ThrowIfDisposed();
            Thread thread = new Thread(WorkerEntry);
            lock (syncLock)
            {
                threads.Add(thread);
                thread.Name = string.Format("{0}Worker #{1}", string.IsNullOrEmpty(threadNamePrefix) ? "" : threadNamePrefix + " " , threads.Count);
                Log.Debug("Created thread " + thread.Name);
            }
            thread.Start();
        }

        /// <summary>
        /// Removes one thread if or when the queue is empty. There is no guarentee as to the 
        /// identity of the thread that will quit or that the thread will quit in a timely fashion.
        /// </summary>
        public void RemoveThread()
        {
            Enqueue(default(TJob)); // needs checking
        }


        /// <summary>
        /// Adds a job to the queue. It will be done when no more jobs are left in front of it.
        /// </summary>
        /// <param name="job">The job do.</param>
        public virtual void Enqueue(TJob job)
        {
            ThrowIfDisposed();
            lock (syncLock)
            {
                if (pause) Resume();
                jobs.Enqueue(job);
                Monitor.PulseAll(syncLock); // inform workers
            }
        }

        /// <summary>
        /// Adds some jobs to the queue. They will be done when no more jobs are left in front of it.
        /// </summary>
        /// <param name="jobs">The jobs do.</param>
        public virtual void Enqueue(IEnumerable<TJob> jobs)
        {
            ThrowIfDisposed();
            lock (syncLock)
            {
                if (pause) Resume();
                foreach (TJob job in jobs)
                {
                    this.jobs.Enqueue(job);
                }
                Monitor.PulseAll(syncLock);  // inform workers
            }
        }

        /// <summary>
        /// Resumes active jobs, if they were paused.
        /// </summary>
        public void Resume()
        {
            ThrowIfDisposed();
            if (!pause)
            {
                Log.Warn("Resume called while not paused. Call Pause() first");
                return;
            }

            Log.Debug("Resume requested");
            this.pause = false;
            pauseHandle.Set();

            Log.Debug("Asking workers to resume.");
            lock (syncLock)
            {
                for (int i = 0; i < activeWorkers.Count; i++)
                {
                    activeWorkers[i].Resume();
                }
            }
            OnWorkResumed();
            Log.Debug("Done resuming.");
        }

        /// <summary>
        /// Pauses active jobs, if they were running.
        /// </summary>
        public void Pause()
        {
            ThrowIfDisposed();
            if (pause)
            {
                Log.Warn("Pause called while paused. Call Resume() first");
                return;
            }

            Log.Debug("Pause requested");

            this.pause = true;
            pauseHandle.Reset(); // Block all threads, so new downloads won't start (unless new items are queued)

            Log.Debug("Asking workers to pause.");
            lock (syncLock)
            {
                for (int i = 0; i < activeWorkers.Count; i++)
                {
                    activeWorkers[i].Pause();
                }
            }
            OnWorkPaused();
            Log.Debug("Done pausing.");
        }

        /// <summary>
        /// Removes all queued jobs.
        /// </summary>
        /// <param name="killRunningJobs">If true, all running jobs will be cancelled as well.</param>
        public void ClearQueue(bool killRunningJobs)
        {
            ThrowIfDisposed();
            lock (syncLock)
            {
                jobs.Clear();
                if (killRunningJobs)
                {
                    for (int i = 0; i < activeWorkers.Count; i++)
                    {
                        activeWorkers[i].Dispose();
                    }
                }
            }
        }


        /// <summary>
        /// Worker thread entry function.
        /// </summary>
        void WorkerEntry()
        {
            using (log4net.NDC.Push(Thread.CurrentThread.Name))
            {
                while (true)
                {
                    TJob job = default(TJob);

                    // If we're paused, this will block
                    // we want to avoid popping items from the queue
                    pauseHandle.WaitOne();

                    lock (syncLock)
                    {
                        while (jobs.Count == 0)
                        {
                            Log.Debug("Queue empty. Monitoring activity.");
                            Monitor.Wait(syncLock); // wait for any work
                        }
                        job = jobs.Dequeue();
                        activeJobs.Add(job);
                        Log.Debug("Pop! Starting work.");
                    }

                    // If we're paused, this will block.
                    // we popped an item, but still will pause
                    pauseHandle.WaitOne();

                    if (job == default(TJob))
                    {
                        lock (syncLock)
                        {
                            threads.Remove(Thread.CurrentThread);   // remove self (for RemoveThread())
                        }
                        Log.Info("Got <null> job. Quitting.");
                        return;
                    }
                    else
                    {
                        Log.Info("Doing the job: " + job.ToString());
                        OnJobStarting(job);
                        if (DoWork(job)) // do work
                            OnJobCompleted(job);
                        else
                            OnJobFailed(job);

                        lock (syncLock)
                        {
                            activeJobs.Remove(job);
                            CheckNotifyCompleted(); // we'll acquire the same lock again
                        }
                    }
                }
            }
        }

        
        /// <summary>
        /// Registers a worker that is active, so that we can Pause and Cancel jobs.
        /// </summary>
        /// <param name="worker">The worker that is performing a task.</param>
        protected void AddActiveWorker(TWorker worker)
        {
            lock (syncLock)
            {
                activeWorkers.Add(worker);
            }
        }

        /// <summary>
        /// Unregisters a worker that has finished it's job.
        /// </summary>
        /// <param name="worker">The worker that is now idle.</param>
        protected void RemoveActiveWorker(TWorker worker)
        {
            lock (syncLock)
            {
                activeWorkers.Remove(worker);
            }
        }

        protected abstract bool DoWork(TJob job);

        /// <summary>
        /// Checks if all tasks has been completed and if true, fires the WorkCompleted event.
        /// </summary>
        private void CheckNotifyCompleted()
        {
            lock (syncLock)
            {
                if ((activeJobs.Count == 0) && (jobs.Count == 0))
                {
                    OnWorkCompleted();
                }
            }
        }

        /// <summary>
        /// Check if Dispose() has been called and if true, throws an exception.
        /// </summary>
        void ThrowIfDisposed()
        {
            if (!isDisposed) return;
            Log.Error("Method called after the instance has been disposed.");
            throw new ObjectDisposedException("This instance has been disposed");
        }

        #region IDisposable Members

        /// <summary>
        /// Stops all running jobs and destroys all active threads.
        /// </summary>
        public void Dispose()
        {
            ClearQueue(true);

            Thread[] _threads = this.threads.ToArray(); // create a local copy because this.threads may be modified by the workers.
            foreach (Thread worker in _threads) Enqueue(default(TJob)); // poison the threads
            foreach (Thread worker in _threads) worker.Join(); // wait for workers to return
            isDisposed = true;  // All method calls will now fail
            System.Diagnostics.Debug.Assert(this.threads.Count == 0);
            Log.Info("All threads disposed");
            OnDisposed();
            operation.OperationCompleted();
        }

        #endregion

        #region ICancelable Members
        
        /// <summary>
        /// Stops all running tasks and empties the queue.
        /// The worker thread pool will be kept alive. 
        /// To destroy all worker threads, call the Dispose() method.
        /// </summary>
        public void Cancel()
        {
            ClearQueue(true);
        }

        #endregion
    }
}
